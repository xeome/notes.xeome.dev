<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Links: [[notes/Linux]]
XDP-Tutorial Introduction XDP is an upstream Linux kernel component that allows users to install packet processing programs into the kernel."><title>XDP-Tutorial</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://xeome.github.io//icon.png><link href=https://xeome.github.io/styles.b3e1e36b0403ac565c9392b3e23ef3b6.min.css rel=stylesheet><link href=https://xeome.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://xeome.github.io/js/darkmode.7f967d9bd2d1cac02e762b5c57efc6ae.min.js></script>
<script src=https://xeome.github.io/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://xeome.github.io/js/popover.abe6a51cc7138c5dff00f151dd627ad1.min.js></script>
<script src=https://xeome.github.io/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://xeome.github.io/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://xeome.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://xeome.github.io/",fetchData=Promise.all([fetch("https://xeome.github.io/indices/linkIndex.541c60d5436a192cd905a1a12b97717a.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://xeome.github.io/indices/contentIndex.1e963768012a7ff091e32caee2c4da60.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://xeome.github.io",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://xeome.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/xeome.github.io\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://xeome.github.io/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://xeome.github.io/>ðŸª´ Quartz 3.3</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>XDP-Tutorial</h1><p class=meta>Last updated
Sep 2, 2022
<a href=https://github.com/xeome/notes/XDP-Tutorial.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#introduction>Introduction</a></li><li><a href=#dependencies>Dependencies</a></li><li><a href=#examples>Examples</a><ol><li><a href=#example-1---writing-a-program-to-pass-all-packets>Example 1 - Writing a program to pass all packets</a></li><li><a href=#example-2---blocking-icmp-packets>Example 2 - Blocking ICMP packets</a></li><li><a href=#example-3---recording-how-many-icmp-packets-arrived>Example 3 - Recording how many ICMP packets arrived</a></li></ol></li><li><a href=#sources>Sources</a></li></ol></nav></details></aside><p>Links: <a href=/notes/Linux rel=noopener class=internal-link data-src=/notes/Linux>notes/Linux</a></p><a href=#xdp-tutorial><h1 id=xdp-tutorial><span class=hanchor arialabel=Anchor># </span>XDP-Tutorial</h1></a><a href=#introduction><h2 id=introduction><span class=hanchor arialabel=Anchor># </span>Introduction</h2></a><p>XDP is an upstream Linux kernel component that allows users to install packet processing programs into the kernel. The programs are written in restricted C and compiled into eBPF byte code. Read the academic paper (pdf) or the Cilium BPF reference guide for a general introduction to XDP.</p><p>This tutorial aims to provide a hands-on introduction to the various steps required to create useful programs with the XDP system. We assume you know the basics of Linux networking and how to configure it with the iproute2 suite of tools, but you have no prior experience with eBPF or XDP. All of the lessons are written in C, and they cover basic pointer arithmetic and aliasing. This tutorial is intended to be a hands-on introduction to the various steps required to successfully write useful programs using the XDP system.</p><p>Please keep in mind that this tutorial was written by a university first-year computer science student who has only recently begun learning XDP.</p><a href=#dependencies><h2 id=dependencies><span class=hanchor arialabel=Anchor># </span>Dependencies</h2></a><p>For basic dependencies refer to
<a href=https://github.com/xdp-project/xdp-tutorial/blob/master/setup_dependencies.org rel=noopener>https://github.com/xdp-project/xdp-tutorial/blob/master/setup_dependencies.org</a>.</p><p>You will also need xdp-tools. If your distribution repositories lack xdp-tools, you can follow the build instructions from here
<a href=https://github.com/xdp-project/xdp-tools rel=noopener>https://github.com/xdp-project/xdp-tools</a> .</p><a href=#examples><h2 id=examples><span class=hanchor arialabel=Anchor># </span>Examples</h2></a><a href=#example-1---writing-a-program-to-pass-all-packets><h3 id=example-1---writing-a-program-to-pass-all-packets><span class=hanchor arialabel=Anchor># </span>Example 1 - Writing a program to pass all packets</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/bpf.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;bpf/bpf_helpers.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>SEC</span><span class=p>(</span><span class=s>&#34;prog&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>xdp_prog_simple</span><span class=p>(</span><span class=k>struct</span> <span class=n>xdp_md</span> <span class=o>*</span><span class=n>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>XDP_PASS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>_license</span><span class=p>[]</span> <span class=n>SEC</span><span class=p>(</span><span class=s>&#34;license&#34;</span><span class=p>)</span> <span class=o>=</span> <span class=s>&#34;GPL&#34;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><a href=#compiling-and-loading-the-example-code><h4 id=compiling-and-loading-the-example-code><span class=hanchor arialabel=Anchor># </span>Compiling and loading the example code</h4></a><p>The LLVM+clang compiler turns this restricted-C code into BPF-byte-code and stores it in an ELF object file, namedÂ <code>xdp_pass.o</code></p><p><strong>Building:</strong></p><p><code>clang -O2 -g -Wall -target bpf -c xdp_pass.c -o xdp_pass.o</code></p><p><strong>Loading:</strong></p><p><code>sudo xdp-loader load -m skb -s prog interface_name xdp_pass.o</code></p><p>Change the interface_name to the name of your interface (for example, <code>eth0</code>, <code>wlan0</code>).</p><p><strong>Unloading:</strong></p><p><code>sudo xdp-loader unload -a interface_name</code>
As previously described, change the interface name.</p><a href=#example-2---blocking-icmp-packets><h3 id=example-2---blocking-icmp-packets><span class=hanchor arialabel=Anchor># </span>Example 2 - Blocking ICMP packets</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/bpf.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/if_ether.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/ip.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/icmp.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define SEC(NAME) __attribute__((section(NAME), used))
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define OVER(x, d) (x + 1 &gt; (typeof(x))d)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* from bpf_helpers.h */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=nf>long</span> <span class=p>(</span><span class=o>*</span><span class=n>bpf_get_prandom_u32</span><span class=p>)(</span><span class=kt>void</span><span class=p>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>	<span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=n>BPF_FUNC_get_prandom_u32</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>csum_replace2</span><span class=p>(</span><span class=kt>uint16_t</span> <span class=o>*</span><span class=n>sum</span><span class=p>,</span> <span class=kt>uint16_t</span> <span class=n>old</span><span class=p>,</span> <span class=kt>uint16_t</span> <span class=n>new</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>uint16_t</span> <span class=n>csum</span> <span class=o>=</span> <span class=o>~*</span><span class=n>sum</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>csum</span> <span class=o>+=</span> <span class=o>~</span><span class=n>old</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>csum</span> <span class=o>+=</span> <span class=n>csum</span> <span class=o>&lt;</span> <span class=p>(</span><span class=kt>uint16_t</span><span class=p>)</span><span class=o>~</span><span class=n>old</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>csum</span> <span class=o>+=</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>csum</span> <span class=o>+=</span> <span class=n>csum</span> <span class=o>&lt;</span> <span class=p>(</span><span class=kt>uint16_t</span><span class=p>)</span><span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=o>*</span><span class=n>sum</span> <span class=o>=</span> <span class=o>~</span><span class=n>csum</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>SEC</span><span class=p>(</span><span class=s>&#34;prog&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>xdp_prog_simple</span><span class=p>(</span><span class=k>struct</span> <span class=n>xdp_md</span> <span class=o>*</span><span class=n>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* data and data_end are pointers to the beginning and end of the packetâ€™s raw
</span></span></span><span class=line><span class=cl><span class=cm>    memory. Note that ctx-&gt;data and ctx-&gt;data_end are of type __u32, so we have
</span></span></span><span class=line><span class=cl><span class=cm>    to perform the casts */</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>data_end</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)(</span><span class=n>uintptr_t</span><span class=p>)</span><span class=n>ctx</span><span class=o>-&gt;</span><span class=n>data_end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>data</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)(</span><span class=n>uintptr_t</span><span class=p>)</span><span class=n>ctx</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=n>old_ttl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>ethhdr</span> <span class=o>*</span><span class=n>eth</span> <span class=o>=</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>iphdr</span> <span class=o>*</span><span class=n>iph</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>iphdr</span> <span class=o>*</span><span class=p>)(</span><span class=n>eth</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>icmphdr</span> <span class=o>*</span><span class=n>icmph</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>icmphdr</span> <span class=o>*</span><span class=p>)(</span><span class=n>iph</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* sanity check needed by the eBPF verifier
</span></span></span><span class=line><span class=cl><span class=cm>    When accessing the data in struct ethhdr, we must make sure we don&#39;t
</span></span></span><span class=line><span class=cl><span class=cm>    access invalid areas by checking whether data + sizeof(struct ethhdr) &gt;
</span></span></span><span class=line><span class=cl><span class=cm>    data_end, and returning without further action if it&#39;s true. This check
</span></span></span><span class=line><span class=cl><span class=cm>    is compulsory by the BPF verifer that verifies your program at runtime. */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>OVER</span><span class=p>(</span><span class=n>eth</span><span class=p>,</span> <span class=n>data_end</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>XDP_DROP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>eth</span><span class=o>-&gt;</span><span class=n>h_proto</span> <span class=o>!=</span> <span class=n>ntohs</span><span class=p>(</span><span class=n>ETH_P_IP</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>XDP_PASS</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* sanity check needed by the eBPF verifier */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>OVER</span><span class=p>(</span><span class=n>iph</span><span class=p>,</span> <span class=n>data_end</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>XDP_DROP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* sanity check needed by the eBPF verifier */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>OVER</span><span class=p>(</span><span class=n>icmph</span><span class=p>,</span> <span class=n>data_end</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>XDP_DROP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 
</span></span></span><span class=line><span class=cl><span class=cm>	struct iphdr {
</span></span></span><span class=line><span class=cl><span class=cm>	#if defined(__LITTLE_ENDIAN_BITFIELD)
</span></span></span><span class=line><span class=cl><span class=cm>		__u8	ihl:4,
</span></span></span><span class=line><span class=cl><span class=cm>			version:4;
</span></span></span><span class=line><span class=cl><span class=cm>	#elif defined (__BIG_ENDIAN_BITFIELD)
</span></span></span><span class=line><span class=cl><span class=cm>		__u8	version:4,
</span></span></span><span class=line><span class=cl><span class=cm>  			ihl:4;
</span></span></span><span class=line><span class=cl><span class=cm>	#else
</span></span></span><span class=line><span class=cl><span class=cm>	#error	&#34;Please fix &lt;asm/byteorder.h&gt;&#34;
</span></span></span><span class=line><span class=cl><span class=cm>	#endif
</span></span></span><span class=line><span class=cl><span class=cm>		__u8	tos;
</span></span></span><span class=line><span class=cl><span class=cm>		__be16	tot_len;
</span></span></span><span class=line><span class=cl><span class=cm>		__be16	id;
</span></span></span><span class=line><span class=cl><span class=cm>		__be16	frag_off;
</span></span></span><span class=line><span class=cl><span class=cm>		__u8	ttl;
</span></span></span><span class=line><span class=cl><span class=cm>		__u8	protocol;
</span></span></span><span class=line><span class=cl><span class=cm>		__sum16	check;
</span></span></span><span class=line><span class=cl><span class=cm>		__be32	saddr;
</span></span></span><span class=line><span class=cl><span class=cm>		__be32	daddr;     
</span></span></span><span class=line><span class=cl><span class=cm>	}; 
</span></span></span><span class=line><span class=cl><span class=cm>	This is the ipheader structure from ip.h; we can see the elements we can access 
</span></span></span><span class=line><span class=cl><span class=cm>    and their types. We can use iph-&gt;protocol to determine whether an incoming 
</span></span></span><span class=line><span class=cl><span class=cm>    packet is an ICMP packet or not. */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>iph</span><span class=o>-&gt;</span><span class=n>protocol</span> <span class=o>!=</span> <span class=n>IPPROTO_ICMP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>XDP_PASS</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* drop icmp */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>iph</span><span class=o>-&gt;</span><span class=n>protocol</span> <span class=o>==</span> <span class=n>IPPROTO_ICMP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>XDP_DROP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* set the TTL to a pseudorandom number 1..255 */</span>
</span></span><span class=line><span class=cl>    <span class=n>old_ttl</span> <span class=o>=</span> <span class=n>iph</span><span class=o>-&gt;</span><span class=n>ttl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>iph</span><span class=o>-&gt;</span><span class=n>ttl</span> <span class=o>=</span> <span class=n>bpf_get_prandom_u32</span><span class=p>()</span> <span class=o>&amp;</span> <span class=mh>0xff</span> <span class=o>?:</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* recalculate the checksum, otherwise the IP stack wil drop it */</span>
</span></span><span class=line><span class=cl>    <span class=n>csum_replace2</span><span class=p>(</span><span class=o>&amp;</span><span class=n>iph</span><span class=o>-&gt;</span><span class=n>check</span><span class=p>,</span> <span class=n>htons</span><span class=p>(</span><span class=n>old_ttl</span> <span class=o>&lt;&lt;</span> <span class=mi>8</span><span class=p>),</span> <span class=n>htons</span><span class=p>(</span><span class=n>iph</span><span class=o>-&gt;</span><span class=n>ttl</span> <span class=o>&lt;&lt;</span> <span class=mi>8</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>XDP_PASS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>_license</span><span class=p>[]</span> <span class=n>SEC</span><span class=p>(</span><span class=s>&#34;license&#34;</span><span class=p>)</span> <span class=o>=</span> <span class=s>&#34;GPL&#34;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><a href=#example-3---recording-how-many-icmp-packets-arrived><h3 id=example-3---recording-how-many-icmp-packets-arrived><span class=hanchor arialabel=Anchor># </span>Example 3 - Recording how many ICMP packets arrived</h3></a><p>In this example, we count the number of ICMP packets received from each individual source address and block incoming packets after the first five.</p><p><img src=/notes/assets/img/BPF_internals.png width=auto></p><p>We can use <strong>eBPF maps</strong> for storing the amount of packets received. Maps are a general-purpose data structure used to store various types of data. They allow data sharing between eBPF kernel programs as well as between kernel and user-space applications.</p><p>Each map type has the following attributes:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ini data-lang=ini><span class=line><span class=cl>   <span class=na>*  type</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=na>*  maximum number of elements</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=na>*  key size in bytes</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=na>*  value size in bytes</span>
</span></span></code></pre></td></tr></table></div></div><p>Example code:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/bpf.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;bpf/bpf_helpers.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/icmp.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/if_ether.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/ip.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/ipv6.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/tcp.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define OVER(x, d) (x + 1 &gt; (typeof(x))d)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* Creating a BPF map for counting ICMP packets as described above */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>bpf_map_def</span> <span class=nf>SEC</span><span class=p>(</span><span class=s>&#34;maps&#34;</span><span class=p>)</span> <span class=n>cnt</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>type</span> <span class=o>=</span> <span class=n>BPF_MAP_TYPE_HASH</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>key_size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>__be32</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>value_size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>max_entries</span> <span class=o>=</span> <span class=mi>65536</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>csum_replace2</span><span class=p>(</span><span class=kt>uint16_t</span> <span class=o>*</span><span class=n>sum</span><span class=p>,</span> <span class=kt>uint16_t</span> <span class=n>old</span><span class=p>,</span> <span class=kt>uint16_t</span> <span class=n>new</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>uint16_t</span> <span class=n>csum</span> <span class=o>=</span> <span class=o>~*</span><span class=n>sum</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>csum</span> <span class=o>+=</span> <span class=o>~</span><span class=n>old</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>csum</span> <span class=o>+=</span> <span class=n>csum</span> <span class=o>&lt;</span> <span class=p>(</span><span class=kt>uint16_t</span><span class=p>)</span><span class=o>~</span><span class=n>old</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>csum</span> <span class=o>+=</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>csum</span> <span class=o>+=</span> <span class=n>csum</span> <span class=o>&lt;</span> <span class=p>(</span><span class=kt>uint16_t</span><span class=p>)</span><span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=o>*</span><span class=n>sum</span> <span class=o>=</span> <span class=o>~</span><span class=n>csum</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>SEC</span><span class=p>(</span><span class=s>&#34;prog&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>xdp_prog_simple</span><span class=p>(</span><span class=k>struct</span> <span class=n>xdp_md</span> <span class=o>*</span><span class=n>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* data and data_end are pointers to the beginning and end of the packetâ€™s raw
</span></span></span><span class=line><span class=cl><span class=cm>    memory. Note that ctx-&gt;data and ctx-&gt;data_end are of type __u32, so we have
</span></span></span><span class=line><span class=cl><span class=cm>    to perform the casts */</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=o>*</span><span class=n>data_end</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)(</span><span class=n>uintptr_t</span><span class=p>)</span><span class=n>ctx</span><span class=o>-&gt;</span><span class=n>data_end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=o>*</span><span class=n>data</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)(</span><span class=n>uintptr_t</span><span class=p>)</span><span class=n>ctx</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=n>old_ttl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=o>*</span><span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Define headers */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>ethhdr</span> <span class=o>*</span><span class=n>eth</span> <span class=o>=</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>iphdr</span> <span class=o>*</span><span class=n>iph</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>iphdr</span> <span class=o>*</span><span class=p>)(</span><span class=n>eth</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>icmphdr</span> <span class=o>*</span><span class=n>icmph</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>icmphdr</span> <span class=o>*</span><span class=p>)(</span><span class=n>iph</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/* sanity check needed by the eBPF verifier
</span></span></span><span class=line><span class=cl><span class=cm>    When accessing the data in struct ethhdr, we must make sure we don&#39;t
</span></span></span><span class=line><span class=cl><span class=cm>    access invalid areas by checking whether data + sizeof(struct ethhdr) &gt;
</span></span></span><span class=line><span class=cl><span class=cm>    data_end, and returning without further action if it&#39;s true. This check
</span></span></span><span class=line><span class=cl><span class=cm>    is compulsory by the BPF verifer that verifies your program at runtime. */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>OVER</span><span class=p>(</span><span class=n>eth</span><span class=p>,</span> <span class=n>data_end</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>XDP_DROP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>eth</span><span class=o>-&gt;</span><span class=n>h_proto</span> <span class=o>!=</span> <span class=n>ntohs</span><span class=p>(</span><span class=n>ETH_P_IP</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>XDP_PASS</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/* sanity check needed by the eBPF verifier */</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>OVER</span><span class=p>(</span><span class=n>iph</span><span class=p>,</span> <span class=n>data_end</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>XDP_DROP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/* sanity check needed by the eBPF verifier */</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>OVER</span><span class=p>(</span><span class=n>icmph</span><span class=p>,</span> <span class=n>data_end</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>XDP_DROP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/* 
</span></span></span><span class=line><span class=cl><span class=cm>	struct iphdr {
</span></span></span><span class=line><span class=cl><span class=cm>	#if defined(__LITTLE_ENDIAN_BITFIELD)
</span></span></span><span class=line><span class=cl><span class=cm>		__u8	ihl:4,
</span></span></span><span class=line><span class=cl><span class=cm>			version:4;
</span></span></span><span class=line><span class=cl><span class=cm>	#elif defined (__BIG_ENDIAN_BITFIELD)
</span></span></span><span class=line><span class=cl><span class=cm>		__u8	version:4,
</span></span></span><span class=line><span class=cl><span class=cm>  			ihl:4;
</span></span></span><span class=line><span class=cl><span class=cm>	#else
</span></span></span><span class=line><span class=cl><span class=cm>	#error	&#34;Please fix &lt;asm/byteorder.h&gt;&#34;
</span></span></span><span class=line><span class=cl><span class=cm>	#endif
</span></span></span><span class=line><span class=cl><span class=cm>		__u8	tos;
</span></span></span><span class=line><span class=cl><span class=cm>		__be16	tot_len;
</span></span></span><span class=line><span class=cl><span class=cm>		__be16	id;
</span></span></span><span class=line><span class=cl><span class=cm>		__be16	frag_off;
</span></span></span><span class=line><span class=cl><span class=cm>		__u8	ttl;
</span></span></span><span class=line><span class=cl><span class=cm>		__u8	protocol;
</span></span></span><span class=line><span class=cl><span class=cm>		__sum16	check;
</span></span></span><span class=line><span class=cl><span class=cm>		__be32	saddr;
</span></span></span><span class=line><span class=cl><span class=cm>		__be32	daddr;     
</span></span></span><span class=line><span class=cl><span class=cm>	}; 
</span></span></span><span class=line><span class=cl><span class=cm>	This is the ipheader structure from ip.h; we can see the elements we can access 
</span></span></span><span class=line><span class=cl><span class=cm>    and their types. We can use iph-&gt;protocol to determine whether an incoming 
</span></span></span><span class=line><span class=cl><span class=cm>    packet is an ICMP packet or not. */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>iph</span><span class=o>-&gt;</span><span class=n>protocol</span> <span class=o>!=</span> <span class=n>IPPROTO_ICMP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>XDP_PASS</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/* Check protocol of the packet */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>iph</span><span class=o>-&gt;</span><span class=n>protocol</span> <span class=o>==</span> <span class=n>IPPROTO_ICMP</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Get source address */</span>
</span></span><span class=line><span class=cl>        <span class=n>__be32</span> <span class=n>source</span> <span class=o>=</span> <span class=n>iph</span><span class=o>-&gt;</span><span class=n>saddr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Get value pointer address*/</span>
</span></span><span class=line><span class=cl>        <span class=n>value</span> <span class=o>=</span> <span class=n>bpf_map_lookup_elem</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cnt</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>source</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=o>*</span><span class=n>value</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>long</span> <span class=n>temp</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* BPF_MAP_UPDATE_ELEM
</span></span></span><span class=line><span class=cl><span class=cm>            Create or update an element (key/value pair) in a
</span></span></span><span class=line><span class=cl><span class=cm>            specified map. For more information visit BPF man page*/</span>
</span></span><span class=line><span class=cl>            <span class=n>bpf_map_update_elem</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cnt</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>source</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>temp</span><span class=p>,</span> <span class=n>BPF_ANY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>value</span> <span class=o>&amp;&amp;</span> <span class=o>*</span><span class=n>value</span> <span class=o>&gt;</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>XDP_DROP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>XDP_PASS</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* set the TTL to a pseudorandom number 1..255 */</span>
</span></span><span class=line><span class=cl>	<span class=n>old_ttl</span> <span class=o>=</span> <span class=n>iph</span><span class=o>-&gt;</span><span class=n>ttl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>iph</span><span class=o>-&gt;</span><span class=n>ttl</span> <span class=o>=</span> <span class=n>bpf_get_prandom_u32</span><span class=p>()</span> <span class=o>&amp;</span> <span class=mh>0xff</span> <span class=o>?:</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/* recalculate the checksum, otherwise the IP stack wil drop it */</span>
</span></span><span class=line><span class=cl>	<span class=n>csum_replace2</span><span class=p>(</span><span class=o>&amp;</span><span class=n>iph</span><span class=o>-&gt;</span><span class=n>check</span><span class=p>,</span> <span class=n>htons</span><span class=p>(</span><span class=n>old_ttl</span> <span class=o>&lt;&lt;</span> <span class=mi>8</span><span class=p>),</span> <span class=n>htons</span><span class=p>(</span><span class=n>iph</span><span class=o>-&gt;</span><span class=n>ttl</span> <span class=o>&lt;&lt;</span> <span class=mi>8</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>XDP_PASS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>_license</span><span class=p>[]</span> <span class=n>SEC</span><span class=p>(</span><span class=s>&#34;license&#34;</span><span class=p>)</span> <span class=o>=</span> <span class=s>&#34;GPL&#34;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><a href=#sources><h2 id=sources><span class=hanchor arialabel=Anchor># </span>Sources</h2></a><p>Many sources have influenced this tutorial, including:</p><ul><li><a href=https://github.com/xdp-project/xdp-tutorial/ rel=noopener>https://github.com/xdp-project/xdp-tutorial/</a></li><li><a href=https://developers.redhat.com/blog/2021/04/01/get-started-with-xdp rel=noopener>https://developers.redhat.com/blog/2021/04/01/get-started-with-xdp</a></li><li><a href=https://www.tigera.io/learn/guides/ebpf/ebpf-xdp/ rel=noopener>https://www.tigera.io/learn/guides/ebpf/ebpf-xdp/</a></li><li><a href=https://www.seekret.io/blog/a-gentle-introduction-to-xdp/ rel=noopener>https://www.seekret.io/blog/a-gentle-introduction-to-xdp/</a></li><li><a href=https://man7.org/linux/man-pages/man2/bpf.2.html rel=noopener>https://man7.org/linux/man-pages/man2/bpf.2.html</a></li></ul></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/notes/Linux/ data-ctx=notes/XDP-Tutorial data-src=/notes/Linux class=internal-link>Linux</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://xeome.github.io/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by xeome using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2022</p><ul><li><a href=https://xeome.github.io/>Home</a></li><li><a href=https://github.com/xeome>Github</a></li></ul></footer></div></div></body></html>